%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 23.2 and Fixed-Point Designer 23.2          %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
%% demInterpolate.m
% UNIVERSAL DEM interpolation - works everywhere
% Drop-in replacement for Module 0 version
% Compatible with: Modules 0-4, HDL Coder, Fixed-Point Converter, AWS F1
%
% Project: Drone Pathfinding - Module 0-5 Integration
% Date: 2025-11-12
% Compatibility: MATLAB R2023b, HDL Coder, Fixed-Point Designer
function z = demInterpolate_fixpt(demData, x, y)
    %DEMINTERPOLATE Bilinear interpolation for DEM elevation queries
    %
    % Universal implementation that works in:
    %   - Module 0: DEM system
    %   - Module 1: Mapping
    %   - Module 2: Coverage paths
    %   - Module 3: A* pathfinding
    %   - Module 4: Mission integration
    %   - Module 5: HDL generation for AWS F1
    %
    % Syntax:
    %   z = demInterpolate(demData, x, y)
    %
    % Inputs:
    %   demData - DEM structure with fields:
    %             .X (101x101 grid of X coordinates)
    %             .Y (101x101 grid of Y coordinates)
    %             .Z (101x101 grid of elevations)
    %             .resolution (grid spacing, e.g., 10 meters)
    %   x - UTM X coordinate (scalar)
    %   y - UTM Y coordinate (scalar)
    %
    % Outputs:
    %   z - Interpolated elevation at (x,y) in meters
    %
    % Features:
    %   - HDL Coder compatible (no try-catch, bounded loops)
    %   - Fixed-Point Designer compatible (simple arithmetic)
    %   - Works with existing Modules 0-4 code
    %   - AWS F1 FPGA ready
    %
    % Example:
    %   demData = load('synthetic_dem_hills.mat').demData;
    %   z = demInterpolate(demData, 500500, 5400500);
    
    %% Input validation (removed for HDL compatibility)
    % Note: For HDL, input validation happens at top level
    % This function assumes valid inputs
    
    %% Extract grid data
    fm = get_fimath();

    X_grid = fi(demData.X, 0, 19, 0, fm);
    Y_grid = fi(demData.Y, 0, 23, 0, fm);
    Z_grid = fi(demData.Z, 0, 16, 9, fm);
    resolution = fi(demData.resolution, 0, 4, 0, fm);
    
    %% Grid bounds
    x_min = fi(X_grid(1, 1), 0, 19, 0, fm);
    y_min = fi(Y_grid(1, 1), 0, 23, 0, fm);
    
    %% Calculate grid position
    % Position in grid coordinates (floating-point)
    i_float = fi(fi_div((fi_signed(x) - x_min), resolution), 0, 16, 9, fm);
    j_float = fi(fi_div((fi_signed(y) - y_min), resolution), 0, 16, 9, fm);
    
    %% Integer grid indices
    i = fi(floor(i_float), 0, 7, 0, fm);
    j = fi(floor(j_float), 0, 7, 0, fm);
    
    %% Bounds checking (clamp to valid range for 101x101 grid)
    % This prevents out-of-bounds access and is HDL-compatible
    if i < fi(0, 0, 1, 0, fm)
        i(:) = 0;
    end
    if j < fi(0, 0, 1, 0, fm)
        j(:) = 0;
    end
    if i >= fi(100, 0, 7, 0, fm)
        i(:) = 99;
    end
    if j >= fi(100, 0, 7, 0, fm)
        j(:) = 99;
    end
    
    %% Calculate fractional offsets (interpolation weights)
    dx = fi(fi_signed(i_float) - i, 0, 16, 15, fm);  % X weight (0 to 1)
    dy = fi(fi_signed(j_float) - j, 0, 16, 15, fm);  % Y weight (0 to 1)
    
    %% Clamp weights to valid range [0, 1]
    % Handles edge cases and ensures valid interpolation
    if dx < fi(0, 0, 1, 0, fm)
        dx(:) = 0;
    end
    if dx > fi(1, 0, 1, 0, fm)
        dx(:) = 1;
    end
    if dy < fi(0, 0, 1, 0, fm)
        dy(:) = 0;
    end
    if dy > fi(1, 0, 1, 0, fm)
        dy(:) = 1;
    end
    
    %% Get four corner elevation values
    % MATLAB uses 1-based indexing, so add 1 to C-style indices
    z11 = fi(Z_grid(j+fi(1, 0, 1, 0, fm), i+fi(1, 0, 1, 0, fm)), 0, 16, 9, fm);    % Bottom-left corner
    z21 = fi(Z_grid(j+fi(1, 0, 1, 0, fm), i+fi(2, 0, 2, 0, fm)), 0, 16, 9, fm);    % Bottom-right corner
    z12 = fi(Z_grid(j+fi(2, 0, 2, 0, fm), i+fi(1, 0, 1, 0, fm)), 0, 16, 9, fm);    % Top-left corner
    z22 = fi(Z_grid(j+fi(2, 0, 2, 0, fm), i+fi(2, 0, 2, 0, fm)), 0, 16, 9, fm);    % Top-right corner
    
    %% Bilinear interpolation
    % Standard formula: z = z11*(1-dx)*(1-dy) + z21*dx*(1-dy) + 
    %                       z12*(1-dx)*dy + z22*dx*dy
    % This is HDL-synthesizable and Fixed-Point compatible
    z = fi(z11 * (fi_signed(fi(1, 0, 1, 0, fm)) - dx) * (fi_signed(fi(1, 0, 1, 0, fm)) - dy) + ...
        z21 * dx * (fi_signed(fi(1, 0, 1, 0, fm)) - dy) + ...
        z12 * (fi_signed(fi(1, 0, 1, 0, fm)) - dx) * dy + ...
        z22 * dx * dy, 0, 16, 9, fm);
    
end



function ntype = divideType(a,b)
    coder.inline( 'always' );
    nt1 = numerictype( a );
    nt2 = numerictype( b );
    maxFL = max( [ min( nt1.WordLength, nt1.FractionLength ), min( nt2.WordLength, nt2.FractionLength ) ] );
    FL = max( maxFL, 24 );
    extraBits = (FL - maxFL);
    WL = nt1.WordLength + nt2.WordLength;
    WL = min( WL, 124 );
    if (WL + extraBits)<64
        ntype = numerictype( nt1.Signed || nt2.Signed, WL + extraBits, FL );
    else
        ntype = numerictype( nt1.Signed || nt2.Signed, WL, FL );
    end
end


function c = fi_div(a,b)
    coder.inline( 'always' );
    a1 = fi( a, 'RoundMode', 'fix' );
    b1 = fi( b, 'RoundMode', 'fix' );
    nType = divideType( a1, b1 );
    if isfi( a ) && isfi( b ) && isscalar( b )
        c1 = divide( nType, a1, b1 );
        c = fi( c1, numerictype( c1 ), fimath( a ) );
    else
        c = fi( a / b, nType );
    end
end


function y = fi_signed(a)
    coder.inline( 'always' );
    if isfi( a ) && ~(issigned( a ))
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = fi( a, new_nt, fimath( a ) );
    else
        y = a;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
